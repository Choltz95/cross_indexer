 === CSC 254 A4: Cross Indexing ===
Chester Holtz - 28264729 - choltz2@u.rochester.edu
Lee Murphy - 28250920 - lmurp14@u.rochester.edu

In this assignment we were required to implement a cross indexer in a either Perl, Ruby, or Python.

== Files ==
README.txt - This file
xref - xref program to parse a dwarfdump log and provide a cross indexer in html for the user to observe relationships between variables, functions, structs, etc.
HTML/ - HTML directory containing a browser navigable cross indexer generated by our xref tool
*.c/*.h/executable - program provided by the user for the xref tool to perform analysis on

== Description ==
This assignment tasked us with implementing a complete cross indexer for any compiled c program. Our xref script runs in a directory containing a compiled c project and a collection of .c and .h files and creates an HTML directory containing a set of html files - one for each .c and .h file and an index.html containing information a list of all the source files and a special link to main along with information about when and where the xref tool was run. 
We were not required to write a c compiler for this project. To achieve our goals, we made use of gccâ€™s g3 tag to generate a DWARF symbol table and parse the table, we used the external program dwarfdump to extract various information. 
We also provide some syntactic highlighting and coloring to make the resulting web representation of the .c and .h files easier to read.

== Approach ==
For our approach we have a set global memory environments which stores variables and subroutines along with their scopes, memory addresses, position in the program, and filename. We represent the scope of blocks and variables as a tree in memory where nodes lower on the tree have lower scope, and nodes on the first level have global scope.

--Dwarfdump inspection--
We scan dwarfdump by making copious use of Pythons regex library re. We developed a different regex based on our needs to declarations as well as references of variables, functions, structs, etc all of varying scope. An example of such a regex is this one to grab uniform (always given regardless of type) header data:
info_rgx = re.compile(r'<(-?[0-9]+)><(.*)><DW_TAG_(.*?)> .*DW_AT_name<(.*?)>')
In this case, we capture groups of associated data and grab them later. By observing the dwarfdump output, we see that the first <> section is always a level number that refers to the general scope of the declaration analyzed. The second is a tag that provides the type of an object and the third is its name. Additionally, there are some type specific datas that we grab once we have knowledge of the type.

We store information captured from this data in an array and return that array to be stored in a key-value dictionary with the key beign the hex identifier.

--Generating HTML--
First, we parse through each .c and .h file for declarations using the following regular expression:
((int\s)|(string\s)|(double\s)|(float\s)|(char\s))(.*?)(=.*)?;
This regex enforces on of an optional set of type declarations and spaces followed by the shortest possible composition of characters followed by an optional = sign and a semicolon. When we encounter a matching declaration, we varify that it is a declaration found by dwarfdump, and if it is, we wrap it in name tags where the name is simply the id. To generate the html, we "parse" each .c and .h file to obtain knowledge of variable and function references. We keep track of the line number and each time we encounter a potential variable reference, we varify its scope and link it to the associated declaration.

--Determining scope--
We determine the scope of declared blocks/variables by generating a scope tree. Nodes on the first level of the scope tree represent items of global scope, and as we traverse downwards, scope increases. Variable declarations are always leaves, but function declarations are not always parents. When we encounter a reference, we look at all possible declarations and traverse the tree bottom up to look for the declaration such that out of all possible declarations, its scope is smallest > the referencing thing and it is visible.

== Problems ==
Unfortunately, our regex is imperfect. There is only so much information we can garner from the dwarfdump log with simple pattern matching. The only perfect pattern matchers perform the same syntactic and semantic analysis as the compiler itself. These issues result in some rare variable recognition/nonrecognition that cannot be fixed. Our cross-indexer is far from perfect.

== Instructions ==
From the command line, run ./xref [arg] where arg is the compiled c binary.
We do not implement recursive subdirectory checking - so all .c and .h files must be placed in the same directory as the xref tool.

== Example Output ==
When our xref tool is called with a  simple fib.c program with an extra function declaration and reference as a parameter: 

/* test comment */
// should ignore this as well
#include<stdio.h>

int g = 1; // global variable
int add() {
  return 1 + 1;
}

int main() {
   int n;
   int first = 0;
   int second = 1;
   int next;
   int c;
   add();
   printf("Enter the number of terms\n");
   scanf("%d",&n);
 
   printf("First %d terms of Fibonacci series are :-\n",n);
   for ( c = 0 ; c < n ; c++ ) {
      int x = 7;
      if ( c <= 1 )
         next = c;
      else {
         next = first + second;
         first = second;
         second = next;
      }
      printf("%d\n",next);
   }
   return 0;
}

it provides an HTML directory containing:

index.html (no wrapping in actual result):
<html><head><title>cross indexer index</title></head><body><h2>Cross Indexer INDEX</h2>
<a href="fib.html">Link to main()</a>
<p>
<a href="fib.html">fib.c</a>
<p>
xref last run on: 2015-11-09 23:18:32.481647
<br>
at: /home/hoover/u5/lmurp14/Desktop/cross_indexer/a4_cross_indexing
</body></html>

fib.html:

<html><head><link rel="stylesheet" href="http://cdn.jsdelivr.net/highlight.js/8.9.1/styles/default.min.css"><script src="http://cdn.jsdelivr.net/highlight.js/8.9.1/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><pre><code class="c">#include&lt;stdio.h&gt;

int<a name="0x116"> <mark>g</mark></a> = 1;

int<a name="0x77"> <mark>add</mark></a>() {
  return 1 + 1;
}

int<a name="0x94"> <mark>main</mark></a>() {
   int<a name="0xb5"> <mark>n</mark></a>;
   int<a name="0xc1"> <mark>first</mark></a> = 0;
   int<a name="0xcf"> <mark>second</mark></a> = 1;
   int<a name="0xdd"> <mark>next</mark></a>;
   int<a name="0xeb"> <mark>c</mark></a>;

   <a href="fib.html#0x77">add</a>();
   printf("Enter the number of terms\n");
   scanf("%d",&<a href="fib.html#0xb5">n</a>);
 
   printf("First %d terms of Fibonacci series are :-\n",<a href="fib.html#0xb5">n</a>);
   for ( <a href="fib.html#0xeb">c</a> = 0 ; <a href="fib.html#0xeb">c</a> &lt; <a href="fib.html#0xb5">n</a> ; <a href="fib.html#0xeb">c</a>++ ) {
      int<a name="0x108"> <mark>x</mark></a> = 7;
      if ( <a href="fib.html#0xeb">c</a> &lt;= 1 )
         <a href="fib.html#0xdd">next</a> = <a href="fib.html#0xeb">c</a>;
      else {
         <a href="fib.html#0xdd">next</a> = <a href="fib.html#0xc1">first</a> + <a href="fib.html#0xcf">second</a>;
         <a href="fib.html#0xc1">first</a> = <a href="fib.html#0xcf">second</a>;
         <a href="fib.html#0xcf">second</a> = <a href="fib.html#0xdd">next</a>;
      }
      printf("%d\n",<a href="fib.html#0xdd">next</a>);
   }
   return 0;
}
</code></pre></body></html>

We also provide a more complex test program in the form of picoc - a multi file c interpreter.
