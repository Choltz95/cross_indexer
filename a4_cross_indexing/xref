#!/usr/bin/env python

from subprocess import call
from collections import defaultdict
import sys
import os
import errno
import re
import datetime

log = "dwarf_log.txt"
statements = []
vars = defaultdict(list)
gloval_vars = defaultdict(list)
sub_programs = defaultdict(list)
symbol_table = {}
current_level = -1

name_stack = []
id_to_name = {}
all_vtypes = {}
vtypes = {}
enums = {}
all_vars = {}
all_local_vars = []
local_vars = []
anons = 0

 # Nasty, but appears to parse the lines we need
dwarf_header_regex = re.compile(r'<(?P<level>\d+)><(?P<statement_id>[0-9+]+)><(?P<type>\w+)>')
dwarf_key_val_regex = re.compile('\s*(?P<keyname>\w+)<(?P<val>[^>]*)>')

def create_directory(path):
    try:
        os.makedirs(path)
    except OSError, e:
        if e.errno != 17:
            print("file not created")

# feed line to input of the form <level><stmtid><type><key,val>
# ie <1><0x94><DW_TAG_variable> DW_AT_name<x> DW_AT_decl_file<0x00000001 /u/choltz2/school/csc_254/a4_cross_indexing/hello_world.c>
#    DW_AT_decl_line<0x00000005> DW_AT_type<<0x0000005b>> DW_AT_external<yes(1)>
#    DW_AT_location<len 0x0009: 033810600000000000: DW_OP_addr 0x00601038>

def get_line(line):
    return 0

# process single dwarf statement
def parse_stmt(type, level, data, statement_id):
    new_level = int(level)
    if new_level > current_level:
        current_level = new_level
        name_stack.append([])
    elif new_level < current_level:
        name_stack = name_stack[:new_level+1]
        current_level = new_level

    name_stack[-1] = [type, statement_id]

    try:
        parent_kind, parent_name = name_stack[-2]
    except IndexError:
        parent_kind, parent_name = (None, None)

    if type == 'DW_TAG_variable' and level == '1':
        if 'DW_AT_location' in data:
            split = data['DW_AT_location'].split()
            if len(split) > 1:
                loc = int(split[1], 0)
                vars[data['DW_AT_name']] = [loc, data['DW_AT_type']]

def get_info(stmt):
    info_rgx = re.compile(r'<(-?[0-9]+)><(.*)><DW_TAG_(.*?)> .*DW_AT_name<(.*?)>')
# add decl_line, DW_AT_location
    loc_rgx = re.compile(r'DW_AT_decl_file<.*/(.*?)>')
    decl_lin_rgx = re.compile(r'DW_AT_decl_line<(.*?)>')
    match = info_rgx.search(stmt)
    match_loc = loc_rgx.search(stmt)
    match_decl = decl_lin_rgx.search(stmt)
    if match is not None:
        if match_loc is not None:
            fname = match_loc.group(1)
        if match_loc is not None:
            #print match_decl.group(1)
            decl_line_hex = match_decl.group(1)
        lvl = match.group(1)
        id = match.group(2)
        tag = match.group(3)
        name = match.group(4)

        # case subprogram
        if(tag == 'subprogram'):
            print 'matched subprogram: ' + name + "()"
        # case variable
        elif(tag == 'variable'):
            if(lvl == '1'):
                print 'matched global variable: ' + name
            else:
                print 'matched variable: ' + name
        # unknown type
        else:
            #print 'unknown tag'
            return None
        return [lvl,id,tag,name,fname, int(decl_line_hex,16)]
    return None

# info of the form[level, id, type, name, file,linenum]
def parse_dd(statements):
    for stmt in statements:
        #print stmt
        info = get_info(stmt)
        if info is not None:
            if info[2] == "variable":
                vars[info[1]].append(info[0])#,info[2],info[3])
                vars[info[1]].append(info[2])
                vars[info[1]].append(info[3])
                vars[info[1]].append(info[4])
                vars[info[1]].append(info[5])
            if info[2] == "subprogram":
                #sub_programs[info[1]].append(info[0],info[2],info[3])
                sub_programs[info[1]].append(info[0])#,info[2],info[3])
                sub_programs[info[1]].append(info[2])
                sub_programs[info[1]].append(info[3])
                sub_programs[info[1]].append(info[4])
                sub_programs[info[1]].append(info[5])
    print vars
    print sub_programs

def generate_html(fname):
    # get function declaration identifier
    subroutine_decl_rgx = re.compile(r'((int\s)|(void\s)|(string\s)|(double\s)|(float\s)|(char\s))(.*?)(?=\s?\()')
    # get function call identifier
    subroutine_iden_rgx = re.compile(r'^(?!(int\s)|(void\s)|(string\s)|(double\s)|(float\s)|(char\s))(.*?)(?=\s?\()')
    # var decl
    var_decl_rgx = re.compile(r'((int\s)|(string\s)|(double\s)|(float\s)|(char\s))(.*?)(=.*)?;')
    # var ident
    var_iden_rgx = re.compile(r'^(?!(int\s)|(string\s)|(double\s)|(float\s)|(char\s))(.*?).*;?') # need to fix, also need to add support for .h files

    r = open(fname, "r")
    w = open("HTML/"+fname[:-1]+"html", "w")
    w.write("<html><head></head><body><pre><code>")
    for line in r:
        match_iden_subroutine = subroutine_iden_rgx.search(line)
        match_decl_subroutine = subroutine_decl_rgx.search(line)
        match_decl_variable = var_decl_rgx.search(line)
        # if brackets in c file, write associated entity for html
        if ">" in line:
            line = line.replace('>', "&gt;")
        if "<" in line:
            line = line.replace('<',"&lt;")
        if match_iden_subroutine is not None: # identify subroutine
            fun_call =  match_iden_subroutine.group(7).strip()
            id = get_key_from_val('s', fun_call)
            line = line.replace(fun_call,"<a href=\"#"+id+"\">"+fun_call+"</a>")
            #w.write("<a href=\"#"+id+"\">"+line+"</a>")
            w.write(line)
        elif match_decl_subroutine is not None: # declare subroutine
            fun_decl = match_decl_subroutine.group(8).strip()
            id = get_key_from_val('s', fun_decl)
            path = sub_programs[id][3].replace(".c",".html")
            line = line.replace(fun_decl,"<a name=\"" + path + "#"+id+"\">" + fun_decl + "</a>")
            #w.write("<a name=\""+id+"\">" + line +"</a>")
            w.write(line)
        elif match_decl_variable is not None: # declare variable
            #print match_decl_variable.group(7).strip()
            var_decl = match_decl_variable.group(7).strip()
            id = get_key_from_val('v', var_decl)
            line = line.replace(var_decl, "<a name=\"#"+id+"\">" + var_decl + "</a>")
            w.write(line)
        elif 1 == 2: # identify variable
            print "variable"
        else:
            w.write(line)
    w.write("</code></pre></body></html>")
    r.close()
    w.close()

def generate_index():
    now = datetime.datetime.now()
    index = open("HTML/index.html","w")
    index.write("<html><head><title>cross indexer index</title></head><body><h2>Cross Indexer INDEX</h2>")
    main_file_key = get_key_from_val('s',"main")
    main_file = sub_programs[main_file_key][3]
    index.write("<a href=\"" +  main_file.replace(".c",".html")  + "\">"+"Link to main()"+"</a>")
    index.write("<p>")
    # get all files
    for file in os.listdir("./HTML"):
        if file.endswith(".html") and file != "index.html": 
            index.write("<a href=\"" + file  + "\">"+file.replace(".html",".c")+"</a>")
            index.write("<p>")
    index.write("xref last run on: " + str(now))
    index.write("<br>")
    index.write("at: " + os.path.dirname(os.path.abspath(__file__)))
    index.write("</body></html>")
    index.close()

def get_key_from_val(type, name):
    if type == 's':
        for key, val in sub_programs.iteritems():
            if name in val:
                return key
    elif type == 'v':
        for key, val in vars.iteritems():
            if name in val:
                return key

def main():
    # generate HTML directory
    create_directory("HTML")
    # save DD to log
    f = open(log, "w")
    call("~cs254/bin/dwarfdump -di " + str(sys.argv[1]), shell=True, stdout = f)
    f.close()
    # array of dd statements
    with open(log) as f:
        statements = f.readlines()
    parse_dd(statements)
    generate_html("hello_world.c")
    generate_index()
main()
